#!/usr/bin/env python3
import sys, os, argparse, re, time, pathlib, textwrap

# ------------------------------------------------------------------------------

# Which boot mode to use, can be (boot, boot_with_proxy, etc.)
TEST_FIXTURE = "boot"
# Scale measured timings by a factor to adjust for different timings on CI
TEST_TIMEOUT_SCALER = 2.5
# Minimum timeout
TEST_TIMEOUT_MIN = 1
# Break comment texts after so many chars
TEST_COMMENT_LEN = 80

# ------------------------------------------------------------------------------

SCRIPT_HEADER = """
import pytest, sys
sys.path.append('../common')
import test_parser as parser

TEST_NAME = '{}'
# May not be used
TEST_TIMEOUT = 5*60

# AUTOGENERATED TEST FUNCTIONS BELOW -------------------------------------------
"""

# ------------------------------------------------------------------------------

def guess_comment(test_fn):
    """
    Very simple way of guessing a tests function based on certain naming
    conventions.
    """
    fn_guess = [
        (r'test_(.*)_pos',
        "Positive tests for {}(), covering the valid ways of using this function."),
        (r'test_(.*)_neg',
        "Negative tests for {}(), covering the invalid ways of using this function thus verifying that it returns error codes instead of crashing"),
        (r'test_(.*)_buffer',
        "Test that buffers/buffer sizes for {}(), behave the same regardless of the mode the API is in."),
    ]
    for regex, cmt in fn_guess:
        mo = re.compile(regex).search(test_fn)
        if mo:
            return textwrap.wrap(cmt.format(mo.group(1)), width=TEST_COMMENT_LEN)
    return []

# ------------------------------------------------------------------------------

def write_test(f, test_fn, arg_times, do_comment, iter_num=None):
    """
    Write the code for a single python function  this may produce multiple calls
    to the parser -- or not.
    """
    if iter_num != None:
        f.write("def %s_%i(%s):\n" % (test_fn, iter_num, TEST_FIXTURE))
    else:
        f.write("def %s(%s):\n" % (test_fn, TEST_FIXTURE))

    f.write('    """\n')
    to_do = True
    if do_comment:
        comment_lines = guess_comment(test_fn)
        for line in comment_lines:
            to_do = False
            f.write("    %s\n" % line)
    if to_do:
        f.write('    <TODO: Describe here what the test does>\n')
    f.write('    """\n')

    for arg, timeout in arg_times:
        f.write("    parser.check_test(%s(TEST_NAME)" % TEST_FIXTURE)
        if timeout:
             f.write(", %i" % (TEST_TIMEOUT_MIN + (timeout * TEST_TIMEOUT_SCALER)))
        else:
             f.write(", TEST_TIMEOUT")
        f.write(", '%s'" % test_fn)
        if arg:
            f.write(", '%s'" % arg)
        f.write(")\n")

# ------------------------------------------------------------------------------

def generate_ta_script(ta_script, tests, do_comment, do_group):
    """
    Generate TA script based on extracted test functions
    """
    test_fn_counts = {}
    written = 0
    with open(ta_script, "w") as f:
        f.write(SCRIPT_HEADER.format(os.path.splitext(os.path.basename(ta_script))[0]))
        f.write("\n")

        for test in tests:
            test_fn = test[0]
            if not do_group:
                if not test_fn in test_fn_counts:
                    test_fn_counts[test_fn] = 0
                write_test(f, test_fn, test[1], do_comment, test_fn_counts[test_fn])
                test_fn_counts[test_fn] = test_fn_counts[test_fn] + 1
            else:
                write_test(f, test_fn, test[1], do_comment)
            f.write("\n")
            written = written+1
    return written

# ------------------------------------------------------------------------------

def extract_tests(test_log, do_group):
    """
    Extract test names (= function + args) from a list of test outputs and possibly
    group different args if shared by single test function
    """
    tests = []
    re_args = re.compile(r'!!! (.*)\((.*)\): OK')
    re_test = re.compile(r'!!! (.*): OK')
    for line, time_diff in test_log:
        test_fn = re_test.search(line).group(1)
        test_args = None
        mo = re_args.search(line)
        if mo:
            test_fn = mo.group(1)
            test_args = mo.group(2)
        tests.append((test_fn, [ (test_args, time_diff) ]))

    if do_group:
        grouped_tests = []
        for test_fn, arg_time in tests:
            grouped_fns = [test[0] for test in grouped_tests]
            if not test_fn in grouped_fns:
                grouped_tests.append( (test_fn, arg_time) )
            else:
                grouped_tests[grouped_fns.index(test_fn)][1].append(arg_time[0])
        tests = grouped_tests
    return tests

# ------------------------------------------------------------------------------

def parse_test_log(input_file):
    """
    Parse test log, either read it from a file or from stdin if no file is given.
    """
    test_log = []
    re_test = re.compile(r'!!! (.*): OK')
    if (input_file):
        with open(input_file, "r") as f:
            for line in f:
                if re_test.search(line):
                    test_log.append((line, None))

    else:
        last_time = time.time()
        print("%s STARTED CAPTURING OUTPUT %s" % ("=" * 50, "=" * 50))
        for line in sys.stdin:
            if re_test.search(line):
                time_diff = time.time() - last_time
                print("+%04.1fs | %s" % (time_diff, line.strip()))
                test_log.append((line.strip(), time_diff))
                last_time = time.time()
            else:
                print("...... | %s" % line.strip())
        print("%s STOPPED CAPTURING OUTPUT %s" % ("=" * 50, "=" * 50))                
    return test_log

# ------------------------------------------------------------------------------

def die(msg):
    print("FATAL: %s. Exiting." % msg)
    sys.exit(-1)

# ------------------------------------------------------------------------------

if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('-i','--input', help='Path to log file of complete test run', \
        required=False, default=None)
    parser.add_argument('-o','--output', help='Path to script file to generate', \
        required=True)
    parser.add_argument('-c', '--comment', help='Guess comments for test functions based on test names', \
        action='store_true', required=False, default=False)
    parser.add_argument('-p', '--print', help='Print the extracted test functions', \
        action='store_true', required=False, default=False)
    parser.add_argument('-g', '--group', \
        help='Group tests with all their arguments into a single pytest function', \
        action='store_true', required=False, default=False)
    args = parser.parse_args()

    if args.input and not pathlib.Path(args.input).is_file():
        die("%s does not exist" % args.input)
    if not args.output.endswith(".py"):
        args.output += ".py"

    test_log = parse_test_log(args.input)
    if test_log == []:
        die("No test outputs found")

    tests = extract_tests(test_log, args.group)

    if args.print:
        print("Found these tests functions:")
        for test in tests:
            arg_time = test[1][0]
            if arg_time[1] and not arg_time[0]:
                test_time = "+%04.1fs " % arg_time[1]
            else:
                test_time = " " * 7 if arg_time[1] else "  "
            print("%s%s" % (test_time, test[0]))
            if arg_time[0]:
                for arg_time in test[1]:
                    test_time = "  " if not arg_time[1] else "+%04.1fs " % arg_time[1]
                    print("%s  %s" % (test_time, arg_time[0]))
            if args.comment:
                comment_lines = guess_comment(test[0])
                for line in comment_lines:
                    print("    %s%s" % (len(test_time) * " ", line))

    n = generate_ta_script(args.output, tests, args.comment, args.group)

    print("Wrote %i test cases to %s" % (n, args.output))
